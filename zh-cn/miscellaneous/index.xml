<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂项 on Fsu0413 的原版 Qt 构建</title>
    <link>/zh-cn/miscellaneous/index.html</link>
    <description>Recent content in 杂项 on Fsu0413 的原版 Qt 构建</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="/zh-cn/miscellaneous/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>本仓库的一些备注</title>
      <link>/zh-cn/miscellaneous/notes-for-this-repo/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh-cn/miscellaneous/notes-for-this-repo/index.html</guid>
      <description>中文 / 多语言支持 虽然这个网站的维护者（Fsu0413，也就是我）是中国人，是中文母语使用者，不过此网站最初做成的时候是只有嘤文版的。
目前我正在逐步在此网站上添加简体中文支持。
得益于 Hugo 自带的多语言支持和近期新换的 Relearn 主题，本网站近期刚刚支持多语言。
目前的中文也仅仅处于刚刚开始组织语言的阶段。有一些内容还没有写完。
不过主要内容均使用中文重新写了一遍，应该不会影响大家下载二进制文件了。
对网站建设有建议和意见的可以去 GitHub 上提出 issue。
可复现的构建 为了实现对 Qt 的可复现的构建，我使用一系列脚本进行构建和打包。
如果您对构建方法感兴趣的话，可以参考下面的 GitHub 仓库。
GitHub
但是不太好的一点是这个网站是手工编辑的。
这个网站的源码如下：
GitHub
对静态构建的备注 我不在大型项目中使用静态构建。我并不认为使用静态构建是很明智的选择。
我可以理解使用静态构建的目的是为了仅发布单一可执行程序，但是事实上有如下限制：
在程序不以 (L)GPLv3 许可协议发布的情况下，使用静态构建并不免费。 部分模块无法构建。（比如 WebEngine 之类的） 不能使用动态链接的插件。 在构建期不执行链接操作，会在后续过程中导致可能的链接问题 这边还是建议在大型项目中停止使用静态构建。相信我，这么做更加自由。
静态 Lite 构建和静态 Full 构建 （2022 年 3 月 8 日更新） 静态 Lite 构建跳过了大多数 Qt 模块。只对 QtCore、QtDeclarative（QtQml 2），QtXmlPatterns 和 QtXXXExtras 进行了构建。
对于在不静态构建整个 Qt 的情况下构建 QtIFW 来说是很有用的。
（2022 年 3 月 8 日更新）Qt 5 静态 Lite 构建也用于我的 QQtPatcher。</description>
    </item>
    <item>
      <title>当前构建状态</title>
      <link>/zh-cn/miscellaneous/current-build-status/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh-cn/miscellaneous/current-build-status/index.html</guid>
      <description>QQtPatcher 支持状态 这是一个 QQtPatcher 支持和测试的版本的列表。
其他版本可能工作，但是也可能静默得失败。
因为 Qt 4 的 qmake -query 不输出 makespec，一个有效的 qbp.json 在为 Qt 4 进行修补时是必要的。
根据 New Features in Qt 5.14 所宣布，Qt 5.14 是可重定位的，这样的话 Qt 5.14 及以后的版本不再需要 QQtPatcher。
我在 Qt 5.14 的早期构建包中附带了 QQtPatcher（只是我忘了修改我的构建脚本里 QQtPatcher 相关的代码）。
这个工具不会在 5.13 上彻底测试。
我宣布 QQtPatcher 不会支持 Qt 5.14 以后的版本。
Qt 版本 构建主机 mkspecs 构建目标 mkspecs 备注 已测试 4.8.7 win32-msvc2010 - Needs qbp.json √ 4.8.7 win32-g++ - Needs qbp.json √ 4.8.7 macx-llvm - Needs qbp.</description>
    </item>
    <item>
      <title>当前的失败项</title>
      <link>/zh-cn/miscellaneous/current-failures/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh-cn/miscellaneous/current-failures/index.html</guid>
      <description>Qt 5.12 以后的 QDoc 使用 MSVC 构建时无法使用静态链接的 clang 它使用 libclang_static.lib 但是 clang 构建中没有这个文件。
我决定在找到使用静态链接的 clang 方法之前，不再提供基于 LLVM 的 QDoc。
2020 年 11 月 3 日更新：
libclang_static.lib 是 Qt 那帮人自己使用脚本打包的。
非常感谢 QtCN 的 lixinwei 提供相关信息。 原帖参考
使用 MinGW 构建 Qt 6.2 系列时命令行过长 参考 QTBUG-96339
暂时使用 CMake 3.20.2 绕过这个问题 QtOpcUa 的问题 目前 QtOpcUa 与 OpenSSL 3.0 系列存在兼容性问题。
在 Qt 那帮人更新他们自己的 open62541 版本之前，暂时禁用 QtOpcUa 的构建。
这个修改将于 Qt 6.2.3 的构建和打包时落实。
看起来 open62541 那帮人并没有把这件事当成问题，即使 OpenSSL 3.</description>
    </item>
    <item>
      <title>之前的历史</title>
      <link>/zh-cn/miscellaneous/histories/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/zh-cn/miscellaneous/histories/index.html</guid>
      <description>2022.10.4 更新 Qt 6.4.0。
更新 Qt 6.2.4 静态构建，使用静态运行时。以前的版本不使用静态运行时。
更新 Qt 6.2.4 LLVM-MinGW 构建。使用 LLVM 15。
删除 Qt 6.3 系列的构建。
2022.9.16 更新 Qt 6.2.4 和 5.15.6，附带更新的 CVE-2022-37434 的补丁。Qt 6.2 系列重新构建，附带 QtWebEngine 6.3.2。
升级到 Xcode 14，重新构建所有的 Qt 6.2 以上的 macOS 主机 / 交叉构建。
2022.9.12 更新 Qt 6.2.4 / 6.3.2 WebAssembly 包。现在启用了预编译头文件支持。
更新 Qt 6.2.4 / 6.3.2 LLVM-MinGW 包。现在启用了 WMF 支持。
更新 Qt 6.4.0-beta4。所有原来在 6.3 上的配置全部可用。使用 RockyLinux 9 进行 Qt 6.4.0 的 Linux 交叉构建主机。WebAssembly 和 LLVM-MinGW 包都使用了今天更新的配置进行构建。</description>
    </item>
  </channel>
</rss>